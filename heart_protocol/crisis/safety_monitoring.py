"""
Safety Monitoring System

Continuous monitoring of user safety indicators with real-time alerts
and proactive intervention capabilities while respecting privacy and autonomy.
"""

import asyncio
from typing import Dict, List, Optional, Any, Callable
from datetime import datetime, timedelta
from enum import Enum
from dataclasses import dataclass
import logging

from ..core.base import CareLevel, Post, CareAssessment
from .escalation_engine import CrisisLevel, EscalationDecision

logger = logging.getLogger(__name__)


class MonitoringLevel(Enum):
    """Levels of safety monitoring intensity"""
    MINIMAL = "minimal"                    # Basic safety awareness
    STANDARD = "standard"                  # Regular monitoring
    ENHANCED = "enhanced"                  # Increased monitoring frequency
    INTENSIVE = "intensive"                # High-frequency monitoring
    CRISIS_WATCH = "crisis_watch"         # Continuous crisis monitoring


class SafetyAlertType(Enum):
    """Types of safety alerts"""
    ESCALATING_RISK = "escalating_risk"           # Risk level increasing
    PATTERN_CHANGE = "pattern_change"             # Behavioral pattern shift
    MISSED_CHECK_IN = "missed_check_in"           # Failed to check in as expected
    CONCERNING_CONTENT = "concerning_content"     # Worrying post/message content
    ISOLATION_DETECTED = "isolation_detected"    # Social isolation indicators
    REGRESSION_DETECTED = "regression_detected"  # Progress regression
    EMERGENCY_KEYWORD = "emergency_keyword"      # Emergency language detected
    SUPPORT_NETWORK_ALERT = "support_network_alert"  # Support system concern


class AlertSeverity(Enum):
    """Severity levels for safety alerts"""
    LOW = "low"                           # Information only
    MODERATE = "moderate"                 # Attention needed
    HIGH = "high"                        # Urgent attention required
    CRITICAL = "critical"                # Immediate intervention needed


@dataclass
class SafetyAlert:
    """Safety alert instance"""
    alert_id: str
    user_id: str
    alert_type: SafetyAlertType
    severity: AlertSeverity
    triggered_at: datetime
    description: str
    indicators: List[str]
    recommended_actions: List[str]
    escalation_needed: bool
    human_review_required: bool
    auto_response_taken: bool
    resolved: bool
    resolved_at: Optional[datetime]
    resolution_notes: Optional[str]


@dataclass
class MonitoringProfile:
    """User's safety monitoring profile"""
    user_id: str
    monitoring_level: MonitoringLevel
    created_at: datetime
    last_updated: datetime
    risk_factors: List[str]
    protective_factors: List[str]
    trigger_keywords: List[str]
    check_in_frequency_hours: int
    alert_thresholds: Dict[str, float]
    monitoring_preferences: Dict[str, Any]
    emergency_contacts: List[Dict[str, Any]]
    active: bool


@dataclass
class SafetyMetric:
    """Individual safety metric measurement"""
    metric_id: str
    user_id: str
    metric_type: str
    value: float
    measured_at: datetime
    context: Dict[str, Any]
    trend_direction: str  # 'improving', 'stable', 'declining'
    significance: float   # 0.0 to 1.0


class SafetyMonitor:
    """
    Continuous safety monitoring system with proactive intervention capabilities.
    
    Key Features:
    - Real-time safety indicator tracking
    - Adaptive monitoring intensity
    - Pattern recognition and trend analysis
    - Automated alert generation
    - Escalation pathway integration
    - Privacy-preserving monitoring
    - User-controlled monitoring preferences
    """
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        
        # Monitoring state
        self.active_monitoring_profiles = {}  # user_id -> MonitoringProfile
        self.active_alerts = {}               # alert_id -> SafetyAlert
        self.safety_metrics = {}              # user_id -> List[SafetyMetric]
        self.monitoring_history = {}          # user_id -> historical_data
        
        # Alert management
        self.alert_handlers = {}              # alert_type -> handler_function
        self.escalation_callbacks = {}        # callback_type -> callback_function
        self.auto_response_actions = {}       # action_type -> action_function
        
        # Monitoring algorithms
        self.pattern_detectors = {}           # pattern_type -> detector_function
        self.trend_analyzers = {}             # trend_type -> analyzer_function
        self.risk_calculators = {}            # risk_type -> calculator_function
        
        # System configuration
        self.default_monitoring_level = MonitoringLevel.STANDARD
        self.alert_retention_days = config.get('alert_retention_days', 30)
        self.metric_retention_days = config.get('metric_retention_days', 90)
        self.max_alerts_per_user_per_day = config.get('max_alerts_per_user_per_day', 10)
        
        self._initialize_monitoring_algorithms()
        self._initialize_alert_handlers()
        self._initialize_auto_responses()
        
        logger.info("Safety Monitoring System initialized")
    
    def _initialize_monitoring_algorithms(self) -> None:
        """Initialize monitoring algorithms and detectors"""
        
        self.pattern_detectors = {
            'escalating_crisis_language': self._detect_escalating_crisis_language,
            'social_isolation_pattern': self._detect_social_isolation,
            'behavioral_regression': self._detect_behavioral_regression,
            'support_network_degradation': self._detect_support_degradation
        }
        
        self.trend_analyzers = {
            'crisis_language_frequency': self._analyze_crisis_language_trend,
            'engagement_level': self._analyze_engagement_trend,
            'emotional_stability': self._analyze_emotional_stability_trend,
            'coping_effectiveness': self._analyze_coping_effectiveness_trend
        }
        
        self.risk_calculators = {
            'immediate_safety_risk': self._calculate_immediate_safety_risk,
            'crisis_escalation_risk': self._calculate_crisis_escalation_risk,
            'isolation_risk': self._calculate_isolation_risk,
            'regression_risk': self._calculate_regression_risk
        }
    
    def _initialize_alert_handlers(self) -> None:
        """Initialize alert handling functions"""
        
        self.alert_handlers = {\n            SafetyAlertType.ESCALATING_RISK: self._handle_escalating_risk_alert,\n            SafetyAlertType.PATTERN_CHANGE: self._handle_pattern_change_alert,\n            SafetyAlertType.MISSED_CHECK_IN: self._handle_missed_check_in_alert,\n            SafetyAlertType.CONCERNING_CONTENT: self._handle_concerning_content_alert,\n            SafetyAlertType.ISOLATION_DETECTED: self._handle_isolation_alert,\n            SafetyAlertType.REGRESSION_DETECTED: self._handle_regression_alert,\n            SafetyAlertType.EMERGENCY_KEYWORD: self._handle_emergency_keyword_alert,\n            SafetyAlertType.SUPPORT_NETWORK_ALERT: self._handle_support_network_alert\n        }\n    \n    def _initialize_auto_responses(self) -> None:\n        \"\"\"Initialize automated response actions\"\"\"\n        \n        self.auto_response_actions = {\n            'gentle_check_in': self._auto_gentle_check_in,\n            'resource_provision': self._auto_provide_resources,\n            'support_activation': self._auto_activate_support,\n            'escalation_preparation': self._auto_prepare_escalation,\n            'emergency_response': self._auto_emergency_response\n        }\n    \n    async def create_monitoring_profile(self, user_id: str,\n                                      user_context: Dict[str, Any],\n                                      user_preferences: Dict[str, Any]) -> MonitoringProfile:\n        \"\"\"Create safety monitoring profile for user\"\"\"\n        \n        try:\n            # Determine appropriate monitoring level\n            monitoring_level = await self._determine_monitoring_level(user_context)\n            \n            # Extract risk and protective factors\n            risk_factors = await self._identify_risk_factors(user_context)\n            protective_factors = await self._identify_protective_factors(user_context)\n            \n            # Set up trigger keywords\n            trigger_keywords = await self._generate_trigger_keywords(user_context)\n            \n            # Configure monitoring frequency\n            check_in_frequency = await self._calculate_check_in_frequency(monitoring_level)\n            \n            # Set alert thresholds\n            alert_thresholds = await self._configure_alert_thresholds(monitoring_level)\n            \n            # Extract emergency contacts\n            emergency_contacts = user_context.get('emergency_contacts', [])\n            \n            profile = MonitoringProfile(\n                user_id=user_id,\n                monitoring_level=monitoring_level,\n                created_at=datetime.utcnow(),\n                last_updated=datetime.utcnow(),\n                risk_factors=risk_factors,\n                protective_factors=protective_factors,\n                trigger_keywords=trigger_keywords,\n                check_in_frequency_hours=check_in_frequency,\n                alert_thresholds=alert_thresholds,\n                monitoring_preferences=user_preferences,\n                emergency_contacts=emergency_contacts,\n                active=True\n            )\n            \n            self.active_monitoring_profiles[user_id] = profile\n            \n            logger.info(f\"Created monitoring profile for user {user_id[:8]}... \"\n                       f\"at {monitoring_level.value} level\")\n            \n            return profile\n            \n        except Exception as e:\n            logger.error(f\"Error creating monitoring profile for user {user_id[:8]}...: {e}\")\n            raise\n    \n    async def monitor_user_safety(self, user_id: str,\n                                 post: Post,\n                                 care_assessment: CareAssessment) -> List[SafetyAlert]:\n        \"\"\"Monitor user safety based on new post/interaction\"\"\"\n        \n        try:\n            alerts = []\n            \n            if user_id not in self.active_monitoring_profiles:\n                logger.debug(f\"No monitoring profile found for user {user_id[:8]}...\")\n                return alerts\n            \n            profile = self.active_monitoring_profiles[user_id]\n            \n            # Update safety metrics\n            await self._update_safety_metrics(user_id, post, care_assessment)\n            \n            # Run pattern detection\n            pattern_alerts = await self._run_pattern_detection(user_id, post, profile)\n            alerts.extend(pattern_alerts)\n            \n            # Run trend analysis\n            trend_alerts = await self._run_trend_analysis(user_id, profile)\n            alerts.extend(trend_alerts)\n            \n            # Check for emergency keywords\n            keyword_alerts = await self._check_emergency_keywords(user_id, post, profile)\n            alerts.extend(keyword_alerts)\n            \n            # Assess overall risk level\n            risk_alerts = await self._assess_risk_level_changes(user_id, care_assessment, profile)\n            alerts.extend(risk_alerts)\n            \n            # Process generated alerts\n            for alert in alerts:\n                await self._process_safety_alert(alert)\n            \n            logger.debug(f\"Generated {len(alerts)} safety alerts for user {user_id[:8]}...\")\n            \n            return alerts\n            \n        except Exception as e:\n            logger.error(f\"Error monitoring user safety for {user_id[:8]}...: {e}\")\n            return []\n    \n    async def _determine_monitoring_level(self, user_context: Dict[str, Any]) -> MonitoringLevel:\n        \"\"\"Determine appropriate monitoring level for user\"\"\"\n        \n        # Check for high-risk indicators\n        if user_context.get('recent_crisis_episode', False):\n            return MonitoringLevel.INTENSIVE\n        \n        if user_context.get('suicide_risk_factors', []):\n            return MonitoringLevel.ENHANCED\n        \n        if user_context.get('multiple_risk_factors', False):\n            return MonitoringLevel.ENHANCED\n        \n        if user_context.get('limited_support_network', False):\n            return MonitoringLevel.ENHANCED\n        \n        # Check for protective factors\n        if user_context.get('strong_support_network', False):\n            return MonitoringLevel.STANDARD\n        \n        if user_context.get('stable_mental_health', False):\n            return MonitoringLevel.MINIMAL\n        \n        return self.default_monitoring_level\n    \n    async def _identify_risk_factors(self, user_context: Dict[str, Any]) -> List[str]:\n        \"\"\"Identify risk factors from user context\"\"\"\n        \n        risk_factors = []\n        \n        # Clinical risk factors\n        if user_context.get('depression_history', False):\n            risk_factors.append('depression_history')\n        \n        if user_context.get('anxiety_disorders', False):\n            risk_factors.append('anxiety_disorders')\n        \n        if user_context.get('substance_use_history', False):\n            risk_factors.append('substance_use_history')\n        \n        if user_context.get('trauma_history', False):\n            risk_factors.append('trauma_history')\n        \n        if user_context.get('previous_suicide_attempts', False):\n            risk_factors.append('previous_suicide_attempts')\n        \n        # Social risk factors\n        if user_context.get('social_isolation', False):\n            risk_factors.append('social_isolation')\n        \n        if user_context.get('recent_loss', False):\n            risk_factors.append('recent_loss')\n        \n        if user_context.get('relationship_problems', False):\n            risk_factors.append('relationship_problems')\n        \n        # Environmental risk factors\n        if user_context.get('financial_stress', False):\n            risk_factors.append('financial_stress')\n        \n        if user_context.get('job_loss', False):\n            risk_factors.append('job_loss')\n        \n        if user_context.get('housing_instability', False):\n            risk_factors.append('housing_instability')\n        \n        return risk_factors\n    \n    async def _identify_protective_factors(self, user_context: Dict[str, Any]) -> List[str]:\n        \"\"\"Identify protective factors from user context\"\"\"\n        \n        protective_factors = []\n        \n        # Social protective factors\n        if user_context.get('strong_family_support', False):\n            protective_factors.append('strong_family_support')\n        \n        if user_context.get('close_friendships', False):\n            protective_factors.append('close_friendships')\n        \n        if user_context.get('community_involvement', False):\n            protective_factors.append('community_involvement')\n        \n        # Personal protective factors\n        if user_context.get('effective_coping_skills', False):\n            protective_factors.append('effective_coping_skills')\n        \n        if user_context.get('religious_spiritual_beliefs', False):\n            protective_factors.append('religious_spiritual_beliefs')\n        \n        if user_context.get('sense_of_purpose', False):\n            protective_factors.append('sense_of_purpose')\n        \n        # Professional protective factors\n        if user_context.get('mental_health_treatment', False):\n            protective_factors.append('mental_health_treatment')\n        \n        if user_context.get('medication_compliance', False):\n            protective_factors.append('medication_compliance')\n        \n        return protective_factors\n    \n    async def _generate_trigger_keywords(self, user_context: Dict[str, Any]) -> List[str]:\n        \"\"\"Generate personalized trigger keywords for monitoring\"\"\"\n        \n        keywords = [\n            # Universal crisis keywords\n            'suicide', 'kill myself', 'end it all', 'want to die',\n            'hurt myself', 'self harm', 'cut myself',\n            'can\\'t go on', 'no point', 'give up',\n            'emergency', 'crisis', 'help me'\n        ]\n        \n        # Add context-specific keywords\n        if 'substance_use_history' in user_context.get('risk_factors', []):\n            keywords.extend(['overdose', 'using again', 'relapsed'])\n        \n        if 'trauma_history' in user_context.get('risk_factors', []):\n            keywords.extend(['triggered', 'flashback', 'nightmares'])\n        \n        if 'domestic_violence' in user_context.get('risk_factors', []):\n            keywords.extend(['abusive', 'violence', 'unsafe at home'])\n        \n        return keywords\n    \n    async def _calculate_check_in_frequency(self, monitoring_level: MonitoringLevel) -> int:\n        \"\"\"Calculate check-in frequency based on monitoring level\"\"\"\n        \n        frequency_mapping = {\n            MonitoringLevel.MINIMAL: 168,      # Weekly\n            MonitoringLevel.STANDARD: 72,      # Every 3 days\n            MonitoringLevel.ENHANCED: 24,      # Daily\n            MonitoringLevel.INTENSIVE: 12,     # Twice daily\n            MonitoringLevel.CRISIS_WATCH: 4    # Every 4 hours\n        }\n        \n        return frequency_mapping.get(monitoring_level, 72)\n    \n    async def _configure_alert_thresholds(self, monitoring_level: MonitoringLevel) -> Dict[str, float]:\n        \"\"\"Configure alert thresholds based on monitoring level\"\"\"\n        \n        base_thresholds = {\n            'crisis_language_frequency': 0.3,\n            'risk_score_increase': 0.2,\n            'engagement_decrease': 0.4,\n            'isolation_score': 0.6,\n            'regression_indicators': 0.3\n        }\n        \n        # Adjust thresholds based on monitoring level\n        level_multipliers = {\n            MonitoringLevel.MINIMAL: 1.5,      # Higher thresholds (less sensitive)\n            MonitoringLevel.STANDARD: 1.0,     # Standard thresholds\n            MonitoringLevel.ENHANCED: 0.8,     # Lower thresholds (more sensitive)\n            MonitoringLevel.INTENSIVE: 0.6,    # Much lower thresholds\n            MonitoringLevel.CRISIS_WATCH: 0.4  # Very low thresholds\n        }\n        \n        multiplier = level_multipliers.get(monitoring_level, 1.0)\n        \n        return {key: value * multiplier for key, value in base_thresholds.items()}\n    \n    async def _update_safety_metrics(self, user_id: str,\n                                   post: Post,\n                                   care_assessment: CareAssessment) -> None:\n        \"\"\"Update safety metrics for user\"\"\"\n        \n        if user_id not in self.safety_metrics:\n            self.safety_metrics[user_id] = []\n        \n        # Create metrics from care assessment\n        metrics = [\n            SafetyMetric(\n                metric_id=f\"care_level_{user_id}_{int(datetime.utcnow().timestamp())}\",\n                user_id=user_id,\n                metric_type='care_level',\n                value=float(care_assessment.care_level.value\n                          if hasattr(care_assessment.care_level, 'value') else 0),\n                measured_at=datetime.utcnow(),\n                context={'post_id': post.id},\n                trend_direction='stable',  # Will be calculated\n                significance=0.8\n            )\n        ]\n        \n        # Add crisis language frequency metric\n        crisis_words = ['crisis', 'emergency', 'help', 'suicide', 'hurt']\n        crisis_word_count = sum(1 for word in crisis_words if word in post.content.lower())\n        \n        if crisis_word_count > 0:\n            metrics.append(SafetyMetric(\n                metric_id=f\"crisis_language_{user_id}_{int(datetime.utcnow().timestamp())}\",\n                user_id=user_id,\n                metric_type='crisis_language_frequency',\n                value=float(crisis_word_count),\n                measured_at=datetime.utcnow(),\n                context={'post_id': post.id, 'word_count': crisis_word_count},\n                trend_direction='stable',\n                significance=0.9\n            ))\n        \n        self.safety_metrics[user_id].extend(metrics)\n        \n        # Calculate trend directions\n        await self._calculate_metric_trends(user_id)\n    \n    async def _calculate_metric_trends(self, user_id: str) -> None:\n        \"\"\"Calculate trend directions for user metrics\"\"\"\n        \n        user_metrics = self.safety_metrics.get(user_id, [])\n        if len(user_metrics) < 2:\n            return\n        \n        # Group metrics by type\n        metrics_by_type = {}\n        for metric in user_metrics:\n            if metric.metric_type not in metrics_by_type:\n                metrics_by_type[metric.metric_type] = []\n            metrics_by_type[metric.metric_type].append(metric)\n        \n        # Calculate trends for each type\n        for metric_type, type_metrics in metrics_by_type.items():\n            if len(type_metrics) >= 2:\n                # Sort by timestamp\n                type_metrics.sort(key=lambda m: m.measured_at)\n                \n                # Compare recent values\n                recent_value = type_metrics[-1].value\n                previous_value = type_metrics[-2].value\n                \n                if recent_value > previous_value * 1.1:\n                    type_metrics[-1].trend_direction = 'declining'  # Higher crisis = worse\n                elif recent_value < previous_value * 0.9:\n                    type_metrics[-1].trend_direction = 'improving'\n                else:\n                    type_metrics[-1].trend_direction = 'stable'\n    \n    async def _run_pattern_detection(self, user_id: str,\n                                   post: Post,\n                                   profile: MonitoringProfile) -> List[SafetyAlert]:\n        \"\"\"Run pattern detection algorithms\"\"\"\n        \n        alerts = []\n        \n        for pattern_type, detector in self.pattern_detectors.items():\n            try:\n                pattern_detected = await detector(user_id, post, profile)\n                if pattern_detected:\n                    alert = await self._create_pattern_alert(user_id, pattern_type, pattern_detected)\n                    alerts.append(alert)\n            except Exception as e:\n                logger.error(f\"Error in pattern detection {pattern_type}: {e}\")\n        \n        return alerts\n    \n    async def _run_trend_analysis(self, user_id: str,\n                                profile: MonitoringProfile) -> List[SafetyAlert]:\n        \"\"\"Run trend analysis algorithms\"\"\"\n        \n        alerts = []\n        \n        for trend_type, analyzer in self.trend_analyzers.items():\n            try:\n                trend_result = await analyzer(user_id, profile)\n                if trend_result and trend_result.get('alert_needed', False):\n                    alert = await self._create_trend_alert(user_id, trend_type, trend_result)\n                    alerts.append(alert)\n            except Exception as e:\n                logger.error(f\"Error in trend analysis {trend_type}: {e}\")\n        \n        return alerts\n    \n    async def _check_emergency_keywords(self, user_id: str,\n                                      post: Post,\n                                      profile: MonitoringProfile) -> List[SafetyAlert]:\n        \"\"\"Check for emergency keywords in post\"\"\"\n        \n        alerts = []\n        post_content_lower = post.content.lower()\n        \n        for keyword in profile.trigger_keywords:\n            if keyword in post_content_lower:\n                alert = SafetyAlert(\n                    alert_id=f\"emergency_keyword_{user_id}_{int(datetime.utcnow().timestamp())}\",\n                    user_id=user_id,\n                    alert_type=SafetyAlertType.EMERGENCY_KEYWORD,\n                    severity=AlertSeverity.HIGH,\n                    triggered_at=datetime.utcnow(),\n                    description=f\"Emergency keyword '{keyword}' detected in user post\",\n                    indicators=[f\"keyword: {keyword}\"],\n                    recommended_actions=['immediate_safety_check', 'crisis_assessment'],\n                    escalation_needed=True,\n                    human_review_required=True,\n                    auto_response_taken=False,\n                    resolved=False,\n                    resolved_at=None,\n                    resolution_notes=None\n                )\n                alerts.append(alert)\n                break  # Only alert once per post\n        \n        return alerts\n    \n    async def _assess_risk_level_changes(self, user_id: str,\n                                       care_assessment: CareAssessment,\n                                       profile: MonitoringProfile) -> List[SafetyAlert]:\n        \"\"\"Assess changes in risk level\"\"\"\n        \n        alerts = []\n        \n        # Check if care level has escalated\n        if hasattr(care_assessment, 'care_level'):\n            if care_assessment.care_level in [CareLevel.HIGH, CareLevel.CRISIS]:\n                alert = SafetyAlert(\n                    alert_id=f\"escalating_risk_{user_id}_{int(datetime.utcnow().timestamp())}\",\n                    user_id=user_id,\n                    alert_type=SafetyAlertType.ESCALATING_RISK,\n                    severity=AlertSeverity.HIGH if care_assessment.care_level == CareLevel.HIGH else AlertSeverity.CRITICAL,\n                    triggered_at=datetime.utcnow(),\n                    description=f\"Care level escalated to {care_assessment.care_level.value}\",\n                    indicators=[f\"care_level: {care_assessment.care_level.value}\"],\n                    recommended_actions=['enhanced_monitoring', 'safety_check', 'escalation_review'],\n                    escalation_needed=care_assessment.care_level == CareLevel.CRISIS,\n                    human_review_required=True,\n                    auto_response_taken=False,\n                    resolved=False,\n                    resolved_at=None,\n                    resolution_notes=None\n                )\n                alerts.append(alert)\n        \n        return alerts\n    \n    async def _detect_escalating_crisis_language(self, user_id: str,\n                                                post: Post,\n                                                profile: MonitoringProfile) -> Optional[Dict[str, Any]]:\n        \"\"\"Detect escalating crisis language patterns\"\"\"\n        \n        crisis_indicators = [\n            'getting worse', 'can\\'t take it', 'falling apart',\n            'losing control', 'breaking down', 'spiraling'\n        ]\n        \n        post_content_lower = post.content.lower()\n        matches = [indicator for indicator in crisis_indicators if indicator in post_content_lower]\n        \n        if matches:\n            return {\n                'pattern_detected': True,\n                'matches': matches,\n                'severity': 'moderate' if len(matches) == 1 else 'high'\n            }\n        \n        return None\n    \n    async def _detect_social_isolation(self, user_id: str,\n                                     post: Post,\n                                     profile: MonitoringProfile) -> Optional[Dict[str, Any]]:\n        \"\"\"Detect social isolation patterns\"\"\"\n        \n        isolation_indicators = [\n            'no one cares', 'all alone', 'nobody understands',\n            'feel invisible', 'completely isolated', 'no friends'\n        ]\n        \n        post_content_lower = post.content.lower()\n        matches = [indicator for indicator in isolation_indicators if indicator in post_content_lower]\n        \n        if matches:\n            return {\n                'pattern_detected': True,\n                'isolation_indicators': matches,\n                'severity': 'moderate'\n            }\n        \n        return None\n    \n    async def _detect_behavioral_regression(self, user_id: str,\n                                          post: Post,\n                                          profile: MonitoringProfile) -> Optional[Dict[str, Any]]:\n        \"\"\"Detect behavioral regression patterns\"\"\"\n        \n        regression_indicators = [\n            'back to old habits', 'relapsed', 'gave up trying',\n            'nothing works', 'stopped caring', 'quit therapy'\n        ]\n        \n        post_content_lower = post.content.lower()\n        matches = [indicator for indicator in regression_indicators if indicator in post_content_lower]\n        \n        if matches:\n            return {\n                'pattern_detected': True,\n                'regression_indicators': matches,\n                'severity': 'high'\n            }\n        \n        return None\n    \n    async def _detect_support_degradation(self, user_id: str,\n                                        post: Post,\n                                        profile: MonitoringProfile) -> Optional[Dict[str, Any]]:\n        \"\"\"Detect support network degradation\"\"\"\n        \n        support_loss_indicators = [\n            'lost my therapist', 'friends abandoned me', 'family doesn\\'t care',\n            'support group ended', 'counselor quit', 'no one to turn to'\n        ]\n        \n        post_content_lower = post.content.lower()\n        matches = [indicator for indicator in support_loss_indicators if indicator in post_content_lower]\n        \n        if matches:\n            return {\n                'pattern_detected': True,\n                'support_loss_indicators': matches,\n                'severity': 'high'\n            }\n        \n        return None\n    \n    async def _analyze_crisis_language_trend(self, user_id: str,\n                                           profile: MonitoringProfile) -> Optional[Dict[str, Any]]:\n        \"\"\"Analyze trend in crisis language frequency\"\"\"\n        \n        user_metrics = self.safety_metrics.get(user_id, [])\n        crisis_metrics = [m for m in user_metrics if m.metric_type == 'crisis_language_frequency']\n        \n        if len(crisis_metrics) < 3:\n            return None\n        \n        # Sort by timestamp\n        crisis_metrics.sort(key=lambda m: m.measured_at)\n        \n        # Calculate trend\n        recent_avg = sum(m.value for m in crisis_metrics[-3:]) / 3\n        previous_avg = sum(m.value for m in crisis_metrics[-6:-3]) / 3 if len(crisis_metrics) >= 6 else 0\n        \n        if recent_avg > previous_avg * 1.5:  # 50% increase\n            return {\n                'alert_needed': True,\n                'trend': 'increasing',\n                'severity': 'moderate',\n                'recent_average': recent_avg,\n                'previous_average': previous_avg\n            }\n        \n        return None\n    \n    async def _analyze_engagement_trend(self, user_id: str,\n                                      profile: MonitoringProfile) -> Optional[Dict[str, Any]]:\n        \"\"\"Analyze user engagement trend\"\"\"\n        \n        # This would analyze posting frequency, response to interactions, etc.\n        # Simplified implementation\n        return None\n    \n    async def _analyze_emotional_stability_trend(self, user_id: str,\n                                                profile: MonitoringProfile) -> Optional[Dict[str, Any]]:\n        \"\"\"Analyze emotional stability trend\"\"\"\n        \n        # This would analyze emotional indicators over time\n        # Simplified implementation\n        return None\n    \n    async def _analyze_coping_effectiveness_trend(self, user_id: str,\n                                                 profile: MonitoringProfile) -> Optional[Dict[str, Any]]:\n        \"\"\"Analyze coping effectiveness trend\"\"\"\n        \n        # This would analyze effectiveness of coping strategies\n        # Simplified implementation\n        return None\n    \n    async def _calculate_immediate_safety_risk(self, user_id: str) -> float:\n        \"\"\"Calculate immediate safety risk score\"\"\"\n        \n        # Simplified risk calculation\n        return 0.3  # Would be more sophisticated in production\n    \n    async def _calculate_crisis_escalation_risk(self, user_id: str) -> float:\n        \"\"\"Calculate crisis escalation risk score\"\"\"\n        \n        return 0.4\n    \n    async def _calculate_isolation_risk(self, user_id: str) -> float:\n        \"\"\"Calculate social isolation risk score\"\"\"\n        \n        return 0.2\n    \n    async def _calculate_regression_risk(self, user_id: str) -> float:\n        \"\"\"Calculate behavioral regression risk score\"\"\"\n        \n        return 0.3\n    \n    async def _create_pattern_alert(self, user_id: str,\n                                  pattern_type: str,\n                                  pattern_data: Dict[str, Any]) -> SafetyAlert:\n        \"\"\"Create alert for detected pattern\"\"\"\n        \n        severity_mapping = {\n            'low': AlertSeverity.LOW,\n            'moderate': AlertSeverity.MODERATE,\n            'high': AlertSeverity.HIGH,\n            'critical': AlertSeverity.CRITICAL\n        }\n        \n        severity = severity_mapping.get(pattern_data.get('severity', 'moderate'), AlertSeverity.MODERATE)\n        \n        return SafetyAlert(\n            alert_id=f\"pattern_{pattern_type}_{user_id}_{int(datetime.utcnow().timestamp())}\",\n            user_id=user_id,\n            alert_type=SafetyAlertType.PATTERN_CHANGE,\n            severity=severity,\n            triggered_at=datetime.utcnow(),\n            description=f\"Pattern detected: {pattern_type}\",\n            indicators=pattern_data.get('matches', []),\n            recommended_actions=['pattern_investigation', 'enhanced_monitoring'],\n            escalation_needed=severity in [AlertSeverity.HIGH, AlertSeverity.CRITICAL],\n            human_review_required=severity != AlertSeverity.LOW,\n            auto_response_taken=False,\n            resolved=False,\n            resolved_at=None,\n            resolution_notes=None\n        )\n    \n    async def _create_trend_alert(self, user_id: str,\n                                trend_type: str,\n                                trend_data: Dict[str, Any]) -> SafetyAlert:\n        \"\"\"Create alert for trend analysis result\"\"\"\n        \n        severity_mapping = {\n            'low': AlertSeverity.LOW,\n            'moderate': AlertSeverity.MODERATE,\n            'high': AlertSeverity.HIGH,\n            'critical': AlertSeverity.CRITICAL\n        }\n        \n        severity = severity_mapping.get(trend_data.get('severity', 'moderate'), AlertSeverity.MODERATE)\n        \n        return SafetyAlert(\n            alert_id=f\"trend_{trend_type}_{user_id}_{int(datetime.utcnow().timestamp())}\",\n            user_id=user_id,\n            alert_type=SafetyAlertType.PATTERN_CHANGE,\n            severity=severity,\n            triggered_at=datetime.utcnow(),\n            description=f\"Trend alert: {trend_type} - {trend_data.get('trend', 'unknown')}\",\n            indicators=[f\"{trend_type}: {trend_data.get('trend', 'unknown')}\"],\n            recommended_actions=['trend_investigation', 'safety_assessment'],\n            escalation_needed=severity in [AlertSeverity.HIGH, AlertSeverity.CRITICAL],\n            human_review_required=True,\n            auto_response_taken=False,\n            resolved=False,\n            resolved_at=None,\n            resolution_notes=None\n        )\n    \n    async def _process_safety_alert(self, alert: SafetyAlert) -> None:\n        \"\"\"Process and handle safety alert\"\"\"\n        \n        # Store alert\n        self.active_alerts[alert.alert_id] = alert\n        \n        # Route to appropriate handler\n        handler = self.alert_handlers.get(alert.alert_type)\n        if handler:\n            await handler(alert)\n        \n        # Execute auto-response if appropriate\n        if alert.severity in [AlertSeverity.HIGH, AlertSeverity.CRITICAL]:\n            await self._execute_auto_response(alert)\n        \n        logger.info(f\"Processed safety alert {alert.alert_id} \"\n                   f\"({alert.alert_type.value}, {alert.severity.value})\")\n    \n    async def _execute_auto_response(self, alert: SafetyAlert) -> None:\n        \"\"\"Execute automated response to alert\"\"\"\n        \n        response_actions = {\n            AlertSeverity.HIGH: ['gentle_check_in', 'resource_provision'],\n            AlertSeverity.CRITICAL: ['emergency_response', 'escalation_preparation']\n        }\n        \n        actions = response_actions.get(alert.severity, [])\n        \n        for action in actions:\n            auto_response = self.auto_response_actions.get(action)\n            if auto_response:\n                await auto_response(alert)\n        \n        alert.auto_response_taken = True\n    \n    async def _handle_escalating_risk_alert(self, alert: SafetyAlert) -> None:\n        \"\"\"Handle escalating risk alert\"\"\"\n        logger.warning(f\"Escalating risk alert for user {alert.user_id[:8]}...\")\n    \n    async def _handle_pattern_change_alert(self, alert: SafetyAlert) -> None:\n        \"\"\"Handle pattern change alert\"\"\"\n        logger.info(f\"Pattern change alert for user {alert.user_id[:8]}...\")\n    \n    async def _handle_missed_check_in_alert(self, alert: SafetyAlert) -> None:\n        \"\"\"Handle missed check-in alert\"\"\"\n        logger.warning(f\"Missed check-in alert for user {alert.user_id[:8]}...\")\n    \n    async def _handle_concerning_content_alert(self, alert: SafetyAlert) -> None:\n        \"\"\"Handle concerning content alert\"\"\"\n        logger.warning(f\"Concerning content alert for user {alert.user_id[:8]}...\")\n    \n    async def _handle_isolation_alert(self, alert: SafetyAlert) -> None:\n        \"\"\"Handle isolation alert\"\"\"\n        logger.warning(f\"Isolation alert for user {alert.user_id[:8]}...\")\n    \n    async def _handle_regression_alert(self, alert: SafetyAlert) -> None:\n        \"\"\"Handle regression alert\"\"\"\n        logger.warning(f\"Regression alert for user {alert.user_id[:8]}...\")\n    \n    async def _handle_emergency_keyword_alert(self, alert: SafetyAlert) -> None:\n        \"\"\"Handle emergency keyword alert\"\"\"\n        logger.critical(f\"Emergency keyword alert for user {alert.user_id[:8]}...\")\n    \n    async def _handle_support_network_alert(self, alert: SafetyAlert) -> None:\n        \"\"\"Handle support network alert\"\"\"\n        logger.warning(f\"Support network alert for user {alert.user_id[:8]}...\")\n    \n    async def _auto_gentle_check_in(self, alert: SafetyAlert) -> None:\n        \"\"\"Automated gentle check-in response\"\"\"\n        logger.info(f\"Auto gentle check-in for user {alert.user_id[:8]}...\")\n    \n    async def _auto_provide_resources(self, alert: SafetyAlert) -> None:\n        \"\"\"Automated resource provision\"\"\"\n        logger.info(f\"Auto resource provision for user {alert.user_id[:8]}...\")\n    \n    async def _auto_activate_support(self, alert: SafetyAlert) -> None:\n        \"\"\"Automated support activation\"\"\"\n        logger.info(f\"Auto support activation for user {alert.user_id[:8]}...\")\n    \n    async def _auto_prepare_escalation(self, alert: SafetyAlert) -> None:\n        \"\"\"Automated escalation preparation\"\"\"\n        logger.info(f\"Auto escalation preparation for user {alert.user_id[:8]}...\")\n    \n    async def _auto_emergency_response(self, alert: SafetyAlert) -> None:\n        \"\"\"Automated emergency response\"\"\"\n        logger.critical(f\"Auto emergency response for user {alert.user_id[:8]}...\")\n    \n    async def resolve_alert(self, alert_id: str,\n                          resolution_notes: str) -> None:\n        \"\"\"Mark alert as resolved\"\"\"\n        \n        if alert_id in self.active_alerts:\n            alert = self.active_alerts[alert_id]\n            alert.resolved = True\n            alert.resolved_at = datetime.utcnow()\n            alert.resolution_notes = resolution_notes\n            \n            logger.info(f\"Resolved safety alert {alert_id}\")\n    \n    def get_active_alerts(self, user_id: Optional[str] = None) -> List[SafetyAlert]:\n        \"\"\"Get active safety alerts\"\"\"\n        \n        active_alerts = [alert for alert in self.active_alerts.values() if not alert.resolved]\n        \n        if user_id:\n            active_alerts = [alert for alert in active_alerts if alert.user_id == user_id]\n        \n        return active_alerts\n    \n    def get_monitoring_profile(self, user_id: str) -> Optional[MonitoringProfile]:\n        \"\"\"Get user's monitoring profile\"\"\"\n        return self.active_monitoring_profiles.get(user_id)\n    \n    async def update_monitoring_level(self, user_id: str,\n                                    new_level: MonitoringLevel) -> None:\n        \"\"\"Update user's monitoring level\"\"\"\n        \n        if user_id in self.active_monitoring_profiles:\n            profile = self.active_monitoring_profiles[user_id]\n            old_level = profile.monitoring_level\n            profile.monitoring_level = new_level\n            profile.last_updated = datetime.utcnow()\n            \n            # Update thresholds and frequency\n            profile.check_in_frequency_hours = await self._calculate_check_in_frequency(new_level)\n            profile.alert_thresholds = await self._configure_alert_thresholds(new_level)\n            \n            logger.info(f\"Updated monitoring level for user {user_id[:8]}... \"\n                       f\"from {old_level.value} to {new_level.value}\")\n    \n    async def get_safety_monitoring_analytics(self) -> Dict[str, Any]:\n        \"\"\"Get safety monitoring system analytics\"\"\"\n        \n        total_profiles = len(self.active_monitoring_profiles)\n        total_active_alerts = len([alert for alert in self.active_alerts.values() if not alert.resolved])\n        total_resolved_alerts = len([alert for alert in self.active_alerts.values() if alert.resolved])\n        \n        # Calculate monitoring level distribution\n        level_distribution = {}\n        for profile in self.active_monitoring_profiles.values():\n            level = profile.monitoring_level.value\n            level_distribution[level] = level_distribution.get(level, 0) + 1\n        \n        # Calculate alert severity distribution\n        severity_distribution = {}\n        for alert in self.active_alerts.values():\n            severity = alert.severity.value\n            severity_distribution[severity] = severity_distribution.get(severity, 0) + 1\n        \n        return {\n            'total_monitoring_profiles': total_profiles,\n            'monitoring_level_distribution': level_distribution,\n            'active_alerts': total_active_alerts,\n            'resolved_alerts': total_resolved_alerts,\n            'alert_severity_distribution': severity_distribution,\n            'monitoring_system_healthy': total_profiles > 0,\n            'pattern_detectors_active': len(self.pattern_detectors),\n            'trend_analyzers_active': len(self.trend_analyzers),\n            'generated_at': datetime.utcnow().isoformat()\n        }"